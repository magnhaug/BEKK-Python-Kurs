<!DOCTYPE html>
<html>
  <head>
    <title>Python-kurs, NTNU, 2012</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <script src="https://github.com/downloads/gnab/remark/remark-0.3.1.min.js" type="text/javascript">
      { "highlightStyle": "solarized_light" }
    </script>
    <script src="../lib/jquery-1.7.1.js" type="text/javascript"></script>
    <script src="../lib/bekk.js" type="text/javascript"></script>

    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>

    <link rel="stylesheet/less" type="text/css" href="../lib/bekk.less">
    <script src="http://lesscss.googlecode.com/files/less-1.1.5.min.js" type="text/javascript"></script>
  </head>
  <body>
    <textarea id="source">

.front-page

# Python-kurs

## Del 2: Idiomatisk python

Forelesning ved NTNU

Magnus Haug / Kjetil Valle

14/03/2012

---

.agenda

# Agenda

* List comprehension
* Generatorer og iteratorer (teori)
* Generator expressions
* Lambda-funksjoner
* Decorators

---

# List comprehension

List comprehensions er en konsis syntaks for å lage eller transformere lister.
Lar deg enkelt *iterere* over lister og *transformere* og *filtrere* elementene.

Syntaks:

    .python
    resultat = [output for var in list if condition]
    
- `output` er elementene som ender opp i den endelige lista. Her kan vi skrive ut `var` direkte, eller som del av et utrykk.
- `list` kan være referanse til en liste, eller en generator/iterator. Iterering fungerer på samme måte her som i vanlige for-løkker.
- `if condition` kan filtrere bort elementer vi ikke ønsker å få med i resultatet. Dette siste leddet er valgfritt.

---

# List comprehension

### Et enkelt eksempel

Iterér over alle tall fra 0 til 10, filtrer ut de som er større enn 5, og gang disse med -1 før de lagres i en ny liste.

    .python
    resultat = []
    for i in range(10):
        if i > 5:
            resultat.append(-i)

Med list comprehension kan vi i stedet skrive dette som:

    .python
    resultat = [-i for i in range(10) if i > 5]
    
Hva skjer her? Vi itererer `for i in range(10)`, filtrerer `if i > 5`, og transfomerer de resterende elementene til `-i`.

---

# List comprehension

List comprehensions kan også gjøres med nestede løkker:

Eksmpel med 2 nivåer:

    .python
    >>> navn = ['Magnus', 'Kjetil']
    >>> hilsen = ['Hei', 'Hallo', 'HAI']
    >>> [h+' '+n for h in hilsen for n in navn] 
    ['Hei Magnus', 'Hei Kjetil', 'Hallo Magnus', 'Hallo Kjetil', 'HAI Magnus', 'HAI Kjetil']

Eller 5...

    .python
    >>> [str(a)+str(b)+str(c)+str(d)+str(e) for a in range(10) for b in range(10) \
    ... for c in range(10) for d in range(10) for e in range(10)]
    ['00000', '00001', '00002', '00003', ..., '99996', '99997', '99998', '99999']

---

# List comprehension

Fra versjon 2.7 finnes det også tilsvarende syntax for å lage set og dictionaries:

    .python
    >>> [ n*n for n in range(5) ] # vanlig list comprehension
    [0, 1, 4, 9, 16]
    >>>
    >>> { n*n for n in range(5) } # set comprehension
    {0, 1, 4, 16, 9}
    >>>
    >>> { n: n*n for n in range(5) } # dict comprehension
    {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

---

# List comprehension

### Oppgaver

Gjør følgende ved hjelp av list comprehensions:

1. Lag en liste med 2er-potenser: `[2, 4, 8, 16, 32, 64, 128, 256, 512, ...]`
1. Lag dictionary over de samme potensene der nøkkel er `i` og verdi er `2**i`.
1. Lag en liste med alle tall mellom 1 og 100 som er delelig på enten 3 eller 7 men ikke begge.
1. Lag liste med alle oddetall som er multiplikat av et tall mellom 3 og 7 og et tall mellom 10 og 14.
1. Generer gangetabellen for tallene fra 1 til 10 som en 2-dimensjonal liste.

---

# Generatorer og iteratorer

Iteratorer er kanskje verdens kjedeligste konsept, men det er en viktig byggesten.
Flere av de python-elementene vi allerede kjenner kan fungere som iteratorer..
F.eks. lister:

    .python
    >>> items = [1, 4, 5]
    >>> it = iter(items)
    >>> it.next()
    1
    >>> it.next()
    4
    >>> it.next()
    5
    >>> it.next()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    StopIteration
    >>>

---

# Generatorer og iteratorer

Syntaktisk sukker

    .python
    >>> items = [1, 4, 5]
    >>> for i in items:
    ...     print i,
    ...
    1 4 5

---

# Generatorer og iteratorer

La oss implementere en iterator selv:

    .python
    class countdown(object):
        def __init__(self,start):
            self.count = start
        def __iter__(self):
            return self
        def next(self):
            if self.count <= 0:
                raise StopIteration
            r = self.count
            self.count -= 1
            return r

Og bruke den:

    .python
    >>> c = countdown(5)
    >>> for i in c:
    ...     print i,
    ...
    5 4 3 2 1

---

# Generatorer og iteratorer

Dette var mye styr, kan det gjøres enklere? Yep, med generatorer:

    .python
    def countdown(i):
        while i > 0:
            yield i
            i -= 1

Resultat:

    .python
    >>> for i in countdown(5):
    ...     print i,
    ...
    5 4 3 2 1

---

# Generatorer og iteratorer

### Hva er nytteverdien?

Uendelige lister, store datamengder:

    .python
    >>> from itertools import count
    >>> c = count()
    >>> c.next()
    0
    >>> c.next()
    1
    >>> c.next()
    2

Spørsmål: Hvordan holder man en uendelig liste i minne?!

---

# Generator expressions

List comprehensions kan automagisk skrives som en generator:

    .python
    >>> liste = [i for i in range(10)]
    >>> generator = (i for i in range(10))
    
    >>> print liste
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    >>> print generator
    <generator object <genexpr> at 0x10ff3e410>
    
    >>> for i in liste:
    ...   print i,
    ... 
    0 1 2 3 4 5 6 7 8 9
    
    >>> for i in liste:
    ...   print i,
    ... 
    0 1 2 3 4 5 6 7 8 9
    
    >>> for i in generator:
    ...   print i,
    ... 
    0 1 2 3 4 5 6 7 8 9
    
    >>> for i in generator:
    ...   print i,
    ... 

Hva skjedde her?

---

# Generator expressions

TODO: kanskje noe om fordeler med generator expressions?

- generator expressions er mer kompakte (men mindre fleksible) enn vanlige generatorer med yield.
- generator expressions kan være mer minnevennlige enn list comprehensions.

Og kanskje noen flere eksmpler så man ser hva de kan være nyttige til?

---

# Generator expressions

### Oppgaver:

1. Lag en list comprehension som lister opp alle partall under 20, og print dem
2. Lag et generator expression som gjør det samme. Print dem.
3. Lag et generator expression som lister opp ALLE partall.
4. Print de første 20 av dem, f.eks. slik:  
    `print [alle_partall.next() for i in xrange(20)]`
5. Lag en 

---

# Lambda-funksjoner

Funksjoner i python er første klasses, dvs. at vi kan gjøre mer med dem enn vi er vant med fra Java:
F.eks. kan vi sende dem inn som parametre til funksjoner:

    .python
    >>> def kall(fn, *args):
    ...   return fn(*args)
    ... 
    >>> def gang_med_to(a):
    ...   return a*2
    ... 
    >>> kall(gang_med_to, 7)
    14

---

# Lambda-funksjoner

Lambdaer er én-linjes funksjoner uten navn:

Vanlig funksjon:

    .python
    >>> def funksjonen_min(num):
    ...     return num*2

    >>> funksjonen_min(3)
    6

Lambda:

    .python
    >>> lambdaen_min = lambda num: num*2
    >>> lambdaen_min(3)
    6

---

# Lambda-funksjoner

Som alle andre funksjoner i Python, kan også lambaer sendes inn som argumenter til andre funksjoner.

    .python
    >>> def double( num ):
    ...     return num * 2
    ... 

    >>> map(double, range(10))
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

Dette blir ofte mer konsist med en lambda:

    .python
    >>> map (lambda num : num * 2, range(10))
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

Akkurat dette tilfellet blir kanskje vel så pent med en list comprehension:

    .python
    >>> [num * 2 for num in range(10)]
    [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

---

# Lambda-funksjoner

### Oppgaver

TODO

---

# Decorators

En dekorator endrer dynamisk funksjonaliteten av en funksjon uten å måtte endre selve funksjonen.

Syntaksen likner veldig på annotasjoner i Java:

    .python
    @dekorator
    def funksjon():
        return "foo"

Eksempelet over er egentlig bare syntaktisk sukker for følgende:

    .python
    def funksjon():
        return "foo"
    funksjon = dekorator(funksjon)
    
En dekorator er altså en funksjon* som tar en funksjon som argument og returnerer en ny funksjon som fungerer som proxy/wrapper for den dekorerte funksjonen.

\* klasser kan også brukes, men vi fokuserer på funksjoner til å begynne med…

---

# Decorators


Den enkleste mulige dekoratoren gjør ingenting:

    .python
    def dekorator(fn):
        return fn

For å gjøre noe mer matnyttig oppretter vi en ny funksjon inni dekorator-funksjonen, og returerer denne.

    .python
    def dekorator(fn):
        def ny_fn():
            # Her kan vi gjøre hva vi vil!
            # Vanligvis inkluderer det et kall til fn().
        return ny_fn

I den nye funksjonen kan vi definere funksjonalitet som skal skje før og etter den dekorerte funksjonen kalles. Eller vi kan la være å kalle den i det hele tatt. Eller vi kan endre argumentene den får inn. Eller...

---

# Decorators

### Et enkelt eksempel 

    .python
    >>> def foo(fn):
    ...     print "inne i dekoratoren"
    ...     def ny_fn():
    ...         print "starter wrapper-funksjonen"
    ...         fn()
    ...         print "slutter wrapper-funksjonen"
    ...     return ny_fn
    ... 
    >>> @foo
    ... def bar():
    ...     print "i den dekorerte funksjon"
    ... 
    inne i dekoratoren
    >>> bar()
    starter wrapper-funksjonen
    i den dekorerte funksjon
    slutter wrapper-funksjonen

---

# Decorators

For å dekorere funksjoner med ulikt antall argumenter bruker vi * og **.

### Eksempel 

Dekorator som teller antall argumenter en funksjon får inn:
    
    .python
    >>> def count_args(fn):
    ...     def wrapper_fn(*args, **kwargs):
    ...         antall = len(args) + len(kwargs)
    ...         print "fikk inn %d argumenter" % antall
    ...         return fn(*args, **kwargs)
    ...     return wrapper_fn
    ... 
    >>> @count_args
    ... def foo(*args, **kwargs):
    ...     pass
    ... 
    >>> foo()
    fikk inn 0 argumenter
    >>> foo(1, 2, 3)
    fikk inn 3 argumenter
    >>> foo(1, 2, 3, bar="baz")
    fikk inn 4 argumenter
    >>> foo(*range(1000000))
    fikk inn 1000000 argumenter

---

# Decorators

Det fungerer også fint å stacke dekoratorer på hverandre.

    .python
    @dekorator1
    @dekorator2
    def funksjon():
        pass
    
Blir det samme som:

    .python
    def funksjon():
        pass
    funksjon = dekorator1(dekorator2(funksjon))

---

# Decorators

Dekoratorene vi har skrevet til nå erstatter funksjonene våre med nye funksjoner.
Vi har dermed endret på hvordan den dekorerte funksjonen ser ut utenfra, ved å endre navn, doc-string, etc.


    .python
    >>> def buu_dekorator(fn):
    ...     def ny_fn(*args, **kwargs):
    ...         # noe artig her
    ...         return fn(*args, **kwargs)
    ...     return ny_fn
    ... 
    >>> @buu_dekorator
    ... def foo():
    ...     """foo sin docstring"""
    ...     pass
    ... 
    >>> foo.__name__
    ny_fn
    >>> foo.__doc__
    None
        
:'( 

---

# Decorators

Dette kan vi passende nok løse ved hjelp av enda en dekorator!

    .python
    >>> from functools import wraps
    >>> 
    >>> def yay_dekorator(fn):
    ...     @wraps(fn)
    ...     def ny_fn(*args, **kwargs):
    ...         # noe artig her
    ...         return fn(*args, **kwargs)
    ...     return ny_fn
    ... 
    >>> @yay_dekorator
    ... def foo():
    ...     """foo sin docstring"""
    ...     pass
    ... 
    >>> foo.__name__
    foo
    >>> foo.__doc__
    foo sin docstring

:D

---

# Decorators

Man kan gjøre mye fancy med dekoratorer. 
For mer informasjon, og flere spenstige eksempler, ta en titt på:

* [http://wiki.python.org/moin/PythonDecoratorLibrary](http://wiki.python.org/moin/PythonDecoratorLibrary)
* [http://stackoverflow.com/questions/739654/understanding-python-decorators/1594484#1594484](http://stackoverflow.com/questions/739654/understanding-python-decorators/1594484#1594484)

---


# Decorators

### Oppgaver

1. Lag dekoratoren `@deprecated` som skriver ut en advarsel hvis noen bruker den dekorerte funksjonern. Bonus hvis du klarer å inkludere navnet på funksjonen i advarselen.
1. Lag en dekorator som tar tiden på den dekorerte funksjonen. 
1. Lag en `@ignore` decorator som gjør at kall til den dekorerte funksjonen ikke lenger gjør noenting.
1. Gitt implementasjonen av fibonacci under, lag dekoratoren `@memoize` som lagrer og gjenbruker delløsningene. Regn ut `fib(100)`.

Slik finner du tidspunkt i Python:

    .python
    from time import time
    tidspunkt = time()

Implementasjon av fibonacci:

    .python
    @memoize
    def fib(a):
        if a in (0,1): return a
        return fib(a-1) + fib(a-2)

---

# Easter Eggs

The Zen of Python

    .python
    import this
    
Hva Python-utviklerne tenker om { og }

    .python
    from __future__ import braces

Alternaltiv implementasjon av Hello World

    .python
    import __hello__

Og sist men ikke minst:

    .python
    import antigravity

---

# Oppsummering

- List comprehensions er en hendig syntaks for å lage/filtrere/mutere lister.
- TODO: noe om iteratorer/generatorer
- Funksjoner er første-klasses i Python, og langt mer fleksible enn i mange andre språk \*host\*Java\*host\*.
- Lambdaer er enlinjes funksjoner uten navn.
- Dekoratorer lar oss endre funksjonalitet på eksisterende funksjoner uten å endre dem direkte.

---

.middle.center

# Spørsmål?

Kom og jobb hos [oss i BEKK](http://www.bekk.no/jobb/stillinger/)

    </textarea>
    <div id="slideshow"></div>
  </body>
</html>
